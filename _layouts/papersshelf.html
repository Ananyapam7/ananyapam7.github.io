---
layout: default
---
<div class="post">

  <header class="post-header">
    <h1 class="post-title">{{ page.title }}</h1>
    <p class="post-description">{{ page.description }}</p>
  </header>

  <article>
    {{ content }}
  </article>

  <div id="chart"></div>

  {%- if page.related_publications != null and page.related_publications.size > 0 -%}
  {% assign publications = page.related_publications | replace: ", ", "," | split: "," | join: "|" %}
  <h2>References</h2>
  <div class="publications">
    {% bibliography -f {{ site.scholar.bibliography }} -q @*[key^={{ publications }}]* %}
  </div>
  {%- endif %}

  {%- if site.giscus and page.giscus_comments -%}
    {% include giscus.html %}
  {%- endif %}

</div>

<style>
  .node:hover {
    cursor: pointer;
    stroke: #000;
    stroke-width: 1.5px;
  }
  .tooltip {
    position: absolute;
    text-align: center;
    width: 200px; /* Updated width */
    height: auto;
    padding: 10px; /* Updated padding */
    font: 12px sans-serif;
    background: grey; /* Updated background color */
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  const width = 960;
  const height = 600;
  const margin = 50;
  const labelPadding = 20;

  const fixedNodeSize = 10;  // Define a fixed size for all nodes

  const svg = d3.select("#chart")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

  // Add background labels
  const labels = [
    { text: "Math", x: width / 2, y: margin / 2 },
    { text: "Statistics", x: width - margin, y: height / 2 },
    { text: "Machine Learning", x: width / 2, y: height - margin / 2 },
    { text: "Finance", x: margin, y: height / 2 }
  ];

  labels.forEach(label => {
    svg.append("text")
      .attr("x", label.x)
      .attr("y", label.y)
      .attr("text-anchor", "middle")
      .attr("fill", "#ccc")
      .attr("font-size", "20px")
      .text(label.text);
  });

  const colorScale = d3.scaleLinear()
    .domain([0, 1])
    .interpolate(d3.interpolateRgb)
    .range(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"]);  // Adjust as needed

  function getColor(d) {
    const total = d.math + d.statistics + d.machine_learning + d.finance;
    const weightedScore = (d.math * 0 + d.statistics * 0.33 + d.machine_learning * 0.67 + d.finance * 1) / total;
    return colorScale(weightedScore);
  }

  const simulation = d3.forceSimulation(papers)
    .force("x", d3.forceX(d => {
      if (d.math > d.statistics && d.math > d.machine_learning && d.math > d.finance) {
        return width / 2;
      } else if (d.statistics > d.math && d.statistics > d.machine_learning && d.statistics > d.finance) {
        return width - margin;
      } else if (d.machine_learning > d.math && d.machine_learning > d.statistics && d.machine_learning > d.finance) {
        return width / 2;
      } else {
        return margin;
      }
    }).strength(0.1))
    .force("y", d3.forceY(d => {
      if (d.math > d.statistics && d.math > d.machine_learning && d.math > d.finance) {
        return margin;
      } else if (d.statistics > d.math && d.statistics > d.machine_learning && d.statistics > d.finance) {
        return height / 2;
      } else if (d.machine_learning > d.math && d.machine_learning > d.statistics && d.machine_learning > d.finance) {
        return height - margin;
      } else {
        return height / 2;
      }
    }).strength(0.1))
    .force("collide", d3.forceCollide(fixedNodeSize + 5))
    .force("avoid-labels", d3.forceCollide(d => {
      if (d.math > d.statistics && d.math > d.machine_learning && d.math > d.finance) {
        return d.y < margin ? labelPadding : 0;
      } else if (d.statistics > d.math && d.statistics > d.machine_learning && d.statistics > d.finance) {
        return d.x > width - margin ? labelPadding : 0;
      } else if (d.machine_learning > d.math && d.machine_learning > d.statistics && d.machine_learning > d.finance) {
        return d.y > height - margin ? labelPadding : 0;
      } else {
        return d.x < margin ? labelPadding : 0;
      }
    }))
    .on("tick", ticked);

  function ticked() {
    const u = svg.selectAll("g")
      .data(papers)
      .join("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .on("mouseover", function(event, d) {
        tooltip.transition()
          .duration(200)
          .style("opacity", .9);
        tooltip.html(`<strong>${d.title}</strong><br>${d.author}<br>${d.abstract}`)  // Removed year
          .style("left", (event.pageX + 5) + "px")
          .style("top", (event.pageY - 28) + "px");
      })
      .on("mouseout", function(d) {
        tooltip.transition()
          .duration(500)
          .style("opacity", 0);
      })
      .on("click", function(event, d) {
        window.open(d.link, "_blank");
      });

    u.append("circle")
      .attr("r", fixedNodeSize)
      .attr("fill", getColor);
  }
</script>